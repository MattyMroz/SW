#include<sys/stat.h>#include<stdlib.h>#include<errno.h>#include<stdio.h>#include<signal.h>#include<time.h>#include<sys/time.h>#include<sys/times.h>externint__io_putchar(intch)__attribute__((weak));externint__io_getchar(void)__attribute__((weak));char*__env[1]={0};char**environ=__env;voidinitialise_monitor_handles(){}int_getpid(void){return1;}int_kill(intpid,intsig){(void)pid;(void)sig;errno=EINVAL;return-1;}void_exit(intstatus){_kill(status,-1);while(1){}}__attribute__((weak))int_read(intfile,char*ptr,intlen){(void)file;intDataIdx;for(DataIdx=0;DataIdx<len;DataIdx++){*ptr++=__io_getchar();}returnlen;}__attribute__((weak))int_write(intfile,char*ptr,intlen){(void)file;intDataIdx;for(DataIdx=0;DataIdx<len;DataIdx++){__io_putchar(*ptr++);}returnlen;}int_close(intfile){(void)file;return-1;}int_fstat(intfile,structstat*st){(void)file;st->st_mode=S_IFCHR;return0;}int_isatty(intfile){(void)file;return1;}int_lseek(intfile,intptr,intdir){(void)file;(void)ptr;(void)dir;return0;}int_open(char*path,intflags,...){(void)path;(void)flags;return-1;}int_wait(int*status){(void)status;errno=ECHILD;return-1;}int_unlink(char*name){(void)name;errno=ENOENT;return-1;}int_times(structtms*buf){(void)buf;return-1;}int_stat(char*file,structstat*st){(void)file;st->st_mode=S_IFCHR;return0;}int_link(char*old,char*new){(void)old;(void)new;errno=EMLINK;return-1;}int_fork(void){errno=EAGAIN;return-1;}int_execve(char*name,char**argv,char**env){(void)name;(void)argv;(void)env;errno=ENOMEM;return-1;}